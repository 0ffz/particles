package me.dvyy.particles.clustering

fun cluster(data: Array<DoubleArray>, radius: Double, minPts: Int): ClusterInfo {
    val clusters = dbscan(data, radius, minPts)
    val sizes = clusters.groupBy { it }
        .mapValues { it.value.size }

    return ClusterInfo(
        clusters,
        sizes = sizes.values.toIntArray(),
        count = sizes.size
    )
}

class ClusterInfo(
    val clusters: IntArray = intArrayOf(),
    val sizes: IntArray = intArrayOf(),
    val count: Int = 0,
)

// Generated by ChatGPT's 4o reasoning model:

fun dbscan(points: Array<DoubleArray>, epsilon: Double, minPts: Int): IntArray {
    val n = points.size
    // Initially, mark all points as noise (-1)
    val clusterIds = IntArray(n) { -1 }
    // Track which points have been visited
    val visited = BooleanArray(n)
    // Cluster identifier, starting from 0
    var clusterId = 0

    // Euclidean distance between two n-dimensional points
    fun distance(p1: DoubleArray, p2: DoubleArray): Double {
        var sum = 0.0
        for (i in p1.indices) {
            val diff = p1[i] - p2[i]
            sum += diff * diff
        }
        return kotlin.math.sqrt(sum)
    }

    // Return the indices of all points within epsilon distance of point at index `pointIdx`
    fun regionQuery(pointIdx: Int): List<Int> {
        val neighbors = mutableListOf<Int>()
        for (i in points.indices) {
            if (distance(points[pointIdx], points[i]) <= epsilon) {
                neighbors.add(i)
            }
        }
        return neighbors
    }

    // Expand the cluster from the seed point using its neighbors
    fun expandCluster(pointIdx: Int, neighbors: MutableList<Int>, clusterId: Int) {
        // Assign the cluster id to the seed point
        clusterIds[pointIdx] = clusterId
        var i = 0
        while (i < neighbors.size) {
            val neighborIdx = neighbors[i]
            if (!visited[neighborIdx]) {
                visited[neighborIdx] = true
                val neighborNeighbors = regionQuery(neighborIdx)
                // If the neighbor has enough points, add its neighbors to the list
                if (neighborNeighbors.size >= minPts) {
                    // Only add new points that aren't already in neighbors
                    for (nn in neighborNeighbors) {
                        if (nn !in neighbors) {
                            neighbors.add(nn)
                        }
                    }
                }
            }
            // If neighbor hasn't been assigned a cluster yet, assign it
            if (clusterIds[neighborIdx] == -1) {
                clusterIds[neighborIdx] = clusterId
            }
            i++
        }
    }

    // Main loop over all points
    for (i in points.indices) {
        if (visited[i]) continue
        visited[i] = true
        val neighbors = regionQuery(i).toMutableList()
        // If not enough neighbors, mark as noise
        if (neighbors.size < minPts) {
            clusterIds[i] = -1
        } else {
            // Otherwise, expand a new cluster from this point
            expandCluster(i, neighbors, clusterId)
            clusterId++
        }
    }

    return clusterIds
}
