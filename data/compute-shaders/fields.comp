#version 430
layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

uniform float gridSize;
uniform int gridRows;
uniform int gridCols;
uniform float epsilon;
uniform float sigma;
uniform float dT;
uniform int count;
uniform float maxForce;
uniform float maxVelocity;

struct ParticleProps {
    vec2 position;
    vec2 velocity;
};

layout (binding = 0) buffer particle2CellKeyBuffer {
    uint particle2CellKey[];
};

//layout (binding = 1) buffer particleVelocitiesBuffer {
//    uint particleVelocities[];
//};

layout (binding = 2) buffer cellOffsetsBuffer {
    uint cellOffsets[];
};

layout (binding = 3) buffer currParticlesBuffer {
    ParticleProps currParticles[];
};

layout (binding = 4) buffer prevParticlesBuffer {
    ParticleProps prevParticles[];
};

layout (binding = 5) buffer colorBuffer {
    vec4 colors[];
};

float lennardJonesForce(float distance) {
    float inv_r = sigma / distance;
    float inv_r6 = inv_r * inv_r * inv_r * inv_r * inv_r * inv_r;
    float inv_r12 = inv_r6 * inv_r6;
    return min(24.0 * epsilon * (2.0 * inv_r12 - inv_r6) / distance, maxForce);
    //    return 24.0 * epsilon * (2.0 * inv_r12 - inv_r6) / distance;
}

void main() {
    // Get the index of the particle we're currently working on from current work group invocation
    //    const uint id = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
    const uint id = gl_GlobalInvocationID.x;
    vec2 position = currParticles[id].position.xy;
    vec2 velocity = currParticles[id].velocity.xy;

    // Get its grid index
    int xGrid = int(position.x / gridSize);
    int yGrid = int(position.y / gridSize);
    uint cellId = xGrid + yGrid * gridCols;

    vec2 netForce = vec2(0.0, 0.0);
    //    if (xGrid != 0 && yGrid != 0 && xGrid != (gridCols - 1) && yGrid != (gridRows - 1)) {
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (cellId + x < 0 || cellId + x >= gridCols * gridRows || cellId + y * gridCols < 0 || cellId + y * gridCols >= gridCols * gridRows) continue;
            uint localCellId = cellId + x + (y * gridCols);
            uint startIndex = cellOffsets[localCellId];

            //TODO swap to a for loop and store a counts buffer for less memory accesses
            for (uint i = startIndex; i < count; i++) {
                if (particle2CellKey[i] != localCellId) break;
                vec2 otherPos = currParticles[i].position;
                if (otherPos == position) continue;
                vec2 direction = position - otherPos;
                float distance = length(direction);
                if (distance > 2.5 * sigma) continue;
                netForce += normalize(direction) * lennardJonesForce(distance);
            }
        }
    }

    // Update position, cap velocity
    //    vec2 prevPosition = prevParticles[id].position;
    //    vec2 velocity = position - prevPosition;
    velocity = length(velocity) > maxVelocity ? normalize(velocity) * maxVelocity : velocity;
    //    float forceAmplitude = length(netForce);
    //    netForce = forceAmplitude > maxForce ? normalize(netForce) * maxForce : netForce;
    vec2 nextPosition = position + velocity * dT + ((netForce * dT * dT) / 2);

    // Write back to buffers (Verlet integration)
    prevParticles[id].position.x = mod(nextPosition.x, gridCols * gridSize);
    prevParticles[id].position.y = mod(nextPosition.y, gridRows * gridSize);
    prevParticles[id].velocity = velocity + netForce / 2.0 * dT; //TODO update to match verlet integration

    // Update color based on netForce
    colors[id] = vec4(log(length(netForce)) / (2 * log(maxForce)), 0, 0, 1);
}
